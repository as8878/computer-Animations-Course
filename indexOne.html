<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Assignment 0 â€“ Animation Framework (Three.js)</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #111827; }
    #overlay { position: fixed; top: 12px; left: 12px; padding: 8px 10px; color: #fff; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: rgba(0,0,0,.35); border-radius: 8px; }
    #hint { position: fixed; bottom: 12px; left: 12px; padding: 6px 8px; color: #cbd5e1; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: rgba(255,255,255,.06); border-radius: 6px; }
  </style>
</head>
<body>
  <div id="overlay"> </div>
  <div id="hint">Press <b>R</b> to restart the 20s run</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
  (function () {
    const scene = new THREE.Scene();
    const FOV = 45;                         
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.PerspectiveCamera(FOV, aspect, 0.1, 1000);
    camera.position.set(0, 0, 300);            
    camera.lookAt(0, 0, 0);                    

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    
    const SIZE = 34;
    const geometry = new THREE.BoxGeometry(SIZE, SIZE, SIZE);
    const material = new THREE.MeshNormalMaterial(); 
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    const Z_CONST = 0;                        

    const FIXED_DT = 1 / 60;                   
    const MAX_TIME = 20;                         

    let simTime = 0;                             
    let accumulator = 0;
    let lastTs = performance.now();
    let running = true;                          

    const overlay = document.getElementById('overlay');

    function update(dt) {
      
      simTime += dt;
      if (simTime > MAX_TIME) simTime = MAX_TIME;

      const t = simTime;                        

      
      cube.position.set(5 * t, 5 * t, Z_CONST);

      
      cube.rotation.set(0, THREE.MathUtils.degToRad(18 * t), 0);  
    }

    function render() {
      renderer.render(scene, camera);
    }

    function animate() {
      if (!running) return;                      

      const now = performance.now();
      let frameDt = (now - lastTs) / 1000;       
      lastTs = now;


      frameDt = Math.min(frameDt, 0.25);

      accumulator += frameDt;


      while (accumulator >= FIXED_DT && simTime < MAX_TIME) {
        update(FIXED_DT);
        accumulator -= FIXED_DT;
      }

      render();

      if (simTime >= MAX_TIME) {
        running = false;                         
        return;
      }

      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    });

    
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        simTime = 0;
        accumulator = 0;
        lastTs = performance.now();
        if (!running) {
          running = true;
          requestAnimationFrame(animate);
        }
      }
    });


    animate();
  })();
  </script>
</body>
</html>
